# -*- coding: utf-8 -*-
"""Lab1 - Feature engineering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rCptxwHJuV0ObKc-qSQ6sMLy1LolpIjf

Import required packages and libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np          # For mathematical calculations
import matplotlib.pyplot as plt  # For plotting graphs
import seaborn as sns
# %matplotlib inline
# import warnings                   # To ignore the warnings
# warnings.filterwarnings("ignore")

train_csv_file_path = "/content/drive/MyDrive/SEM 7 - ML/Lab 1 - Feature Engineering/train.csv"
valid_csv_file_path = "/content/drive/MyDrive/SEM 7 - ML/Lab 1 - Feature Engineering/valid.csv"

"""# Train dataset"""

# importing train dataset

train_df = pd.read_csv(train_csv_file_path)
train_df.head()

train_df.shape

"""# Validation dataset"""

valid_df = pd.read_csv(valid_csv_file_path)
valid_df.head()

valid_df.shape

"""# Exploratory Data analysis"""

train_df.describe()

"""## Renaming the class labels"""

train_df.rename(columns={'label_1': 'speaker_ID', 'label_2': 'speaker_age', 'label_3': 'speaker_gender', 'label_4': 'speaker_accent'}, inplace=True)

valid_df.rename(columns={'label_1': 'speaker_ID', 'label_2': 'speaker_age', 'label_3': 'speaker_gender', 'label_4': 'speaker_accent'}, inplace=True)

valid_df.describe()

"""## Identification of class imbalance issue"""

train_df.speaker_accent.value_counts()

# I noticed that “speaker_accent” has a class imbalance issue. Fig 3 below showcases that (the value ‘6’ has very high frequency compared to other values).
# To address this issue, I used class_weight='balanced' parameter when training the models.

train_df.speaker_ID.value_counts()

train_df.speaker_age.value_counts()

train_df.speaker_gender.value_counts()

"""## Checking for null values"""

# Check for null/NaN values in all columns
print(train_df.isna().any())

sns.heatmap(train_df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

# note that the missing values represented as yellow bar (top right hand corner in below heatmap)

# Check for null/NaN values in all columns
print(valid_df.isna().any())

sns.heatmap(valid_df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

# note that the missing values represented as yellow bar (top right hand corner in below heatmap)

"""## Replace missing values with the mean of the column"""

# from the above heatmaps we can see some missing values in speaker_age column

# Replace missing values with the mean of the column
train_df.speaker_age.fillna(round(train_df.speaker_age.mean()), inplace=True)

sns.heatmap(train_df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

# Note that now the yellow bar dissapears because we assigned the mean value for missing speaker_age values

valid_df.speaker_age.fillna(round(valid_df.speaker_age.mean()), inplace=True)

sns.heatmap(valid_df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

# Note that now the yellow bar dissapears because we assigned the mean value for missing speaker_age values

"""# Running Models for the raw features"""

# Get features (X) and target (y) from the testing dataset
valid_X = valid_df.drop(columns=['speaker_ID', 'speaker_age', 'speaker_gender', 'speaker_accent'])
valid_speaker_IDs = valid_df['speaker_ID']
valid_speaker_ages = valid_df['speaker_age']
valid_speaker_genders = valid_df['speaker_gender']
valid_speaker_accents = valid_df['speaker_accent']

from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

# Get features (X) and target (y) from the training dataset
train_X = train_df.drop(columns=['speaker_ID', 'speaker_age', 'speaker_gender', 'speaker_accent'])
train_speaker_IDs = train_df['speaker_ID']
train_speaker_ages = train_df['speaker_age']
train_speaker_genders = train_df['speaker_gender']
train_speaker_accents = train_df['speaker_accent']

import warnings
# function to run all models and print the best accuracy along with the model name
# it will train all the models based on train_X (training dataset) and give accuracies based on test_X (testing dataset)
def run_models_and_check_with_test_dataset(train_features, train_class_labels, test_features, test_class_labels):

  accuracies = []
  warnings.filterwarnings("ignore")
  svm_model = SVC(class_weight='balanced')
  svm_model.fit(train_features, train_class_labels)

  nb_model = GaussianNB()
  nb_model.fit(train_features, train_class_labels)

  logreg_model = LogisticRegression(class_weight='balanced')
  logreg_model.fit(train_features, train_class_labels)

  rf_model = RandomForestClassifier(class_weight='balanced')
  rf_model.fit(train_features, train_class_labels)

  # Prediction
  svm_predictions = svm_model.predict(test_features)
  nb_predictions = nb_model.predict(test_features)
  logreg_predictions = logreg_model.predict(test_features)
  rf_predictions = rf_model.predict(test_features)

  name_of_max_model = "SVM"

  # Evaluate the models
  # print("Support Vector Machine:")
  accuracy = accuracy_score(test_class_labels, svm_predictions)
  accuracies.append(accuracy)
  # print("Accuracy:", accuracy)

  # print("Naive Bayes:")
  accuracy = accuracy_score(test_class_labels, nb_predictions)
  accuracies.append(accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "NB"
  # print("Accuracy:", accuracy)

  # print("Logistic Regression:")
  accuracy = accuracy_score(test_class_labels, logreg_predictions)
  accuracies.append(accuracy)
  # print("Accuracy:", accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "Logistic Regression"

  # print("Random Forest:")
  accuracy = accuracy_score(test_class_labels, rf_predictions)
  accuracies.append(accuracy)
  # print("Accuracy:", accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "Random Forest"


  print("Best accuracy out of SVM, NB, Logigstic Reg, and Random Forest is:", max(accuracies), "(",name_of_max_model,")")


def run_models_and_check_with_train_test_split_on_train_dataset(train_features, train_class_labels):
  warnings.filterwarnings("ignore")
  X_train, X_test, y_train, y_test = train_test_split(train_features, train_class_labels, test_size=0.2, random_state=42)
  accuracies = []

  svm_model = SVC(class_weight='balanced')
  svm_model.fit(X_train, y_train)

  nb_model = GaussianNB()
  nb_model.fit(X_train, y_train)

  logreg_model = LogisticRegression(class_weight='balanced')
  logreg_model.fit(X_train, y_train)

  rf_model = RandomForestClassifier(class_weight='balanced')
  rf_model.fit(X_train, y_train)

  # Prediction
  svm_predictions = svm_model.predict(X_test)
  nb_predictions = nb_model.predict(X_test)
  logreg_predictions = logreg_model.predict(X_test)
  rf_predictions = rf_model.predict(X_test)

  name_of_max_model = "SVM"

  # Evaluate the models
  # print("Support Vector Machine:")
  accuracy = accuracy_score(y_test, svm_predictions)
  accuracies.append(accuracy)
  # print("Accuracy:", accuracy)

  print("Naive Bayes:")
  accuracy = accuracy_score(y_test, nb_predictions)
  accuracies.append(accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "NB"
  # print("Accuracy:", accuracy)

  # print("Logistic Regression:")
  accuracy = accuracy_score(y_test, logreg_predictions)
  accuracies.append(accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "Logistic Regression"
  # print("Accuracy:", accuracy)

  # print("Random Forest:")
  accuracy = accuracy_score(y_test, rf_predictions)
  accuracies.append(accuracy)
  if accuracy > max(accuracies):
    name_of_max_model = "Random Forest"
  # print("Accuracy:", accuracy)

  print("Best accuracy out of SVM, NB, Logigstic Reg, and Random Forest is:", max(accuracies), "(",name_of_max_model,")")

"""## Results

### Accuracies on validation dataset
"""

run_models_and_check_with_test_dataset(train_X, train_speaker_IDs, valid_X, valid_speaker_IDs)
run_models_and_check_with_test_dataset(train_X, train_speaker_ages, valid_X, valid_speaker_ages)
run_models_and_check_with_test_dataset(train_X, train_speaker_genders, valid_X, valid_speaker_genders)
run_models_and_check_with_test_dataset(train_X, train_speaker_accents, valid_X, valid_speaker_accents)

"""### Accuracies on train dataset (with a 80:20 train:test split)"""

run_models_and_check_with_train_test_split_on_train_dataset(train_X, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(train_X, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(train_X, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(train_X, train_speaker_accents)

"""# Featuring Engineering

## Standardization the features
"""

print(train_X.shape)

from sklearn.preprocessing import StandardScaler

train_X_std = pd.DataFrame()
ss = StandardScaler()

ss.fit(train_X)
train_X_std = ss.transform(train_X)
train_X_std = pd.DataFrame(train_X_std)

train_X_std.describe()

from sklearn.preprocessing import StandardScaler

valid_X_std = pd.DataFrame()
valid_X_std = ss.transform(valid_X)
valid_X_std = pd.DataFrame(valid_X_std)

valid_X_std.describe()

train_X_std.shape

valid_X_std.shape

run_models_and_check_with_test_dataset(train_X_std, train_speaker_IDs, valid_X_std, valid_speaker_IDs)
run_models_and_check_with_test_dataset(train_X_std, train_speaker_ages, valid_X_std, valid_speaker_ages)
run_models_and_check_with_test_dataset(train_X_std, train_speaker_genders, valid_X_std, valid_speaker_genders)
run_models_and_check_with_test_dataset(train_X_std, train_speaker_accents, valid_X_std, valid_speaker_accents)

run_models_and_check_with_train_test_split_on_train_dataset(train_X_std, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(train_X_std, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(train_X_std, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(train_X_std, train_speaker_accents)

"""## Check for Constant and quasi-constant features"""

from sklearn.feature_selection import VarianceThreshold

def constant_feature_detect(data,threshold=0.98):
    """ detect features that show the same value for the
    majority/all of the observations (constant/quasi-constant features)

    Parameters
    ----------
    data : pd.Dataframe
    threshold : threshold to identify the variable as constant

    Returns
    -------
    list of variables names
    """

    data_copy = data.copy(deep=True)
    quasi_constant_feature = []
    for feature in data_copy.columns:
        predominant = (data_copy[feature].value_counts() / float(
                      len(data_copy))).sort_values(ascending=False).values[0]
        if predominant >= threshold:
            quasi_constant_feature.append(feature)
    print(len(quasi_constant_feature),' variables are found to be almost constant')
    return quasi_constant_feature

quasi_constant_feature = constant_feature_detect(data=train_X_std,threshold=0.8)
quasi_constant_feature

# No quasi constant features found (check below output)

# Instantiate VarianceThreshold with a threshold value (e.g., 0.01)
threshold_value = 0.01
selector = VarianceThreshold(threshold=threshold_value)

# Fit and transform the DataFrame to identify and remove low-variance features
df_transformed = selector.fit_transform(train_X_std)

# Get the indices of the selected features
selected_indices = selector.get_support(indices=True)

# Get the names of the selected features
selected_features = train_X_std.columns[selected_indices]

# Create a new DataFrame with selected features
df_selected = train_X_std[selected_features]

print("Original DataFrame:")
print(train_X_std.shape)
print("\nDataFrame after removing constant/quasi-constant features:")
print(df_selected.shape)

# No feature reduction as per the below output (shows all the 256 columns)

"""## Check for highly-correlated features"""

def corr_feature_detect(data,threshold=0.8):
    """ detect highly-correlated features of a Dataframe
    Parameters
    ----------
    data : pd.Dataframe
    threshold : threshold to identify the variable correlated

    Returns
    -------
    pairs of correlated variables
    """

    corrmat = data.corr()
    corrmat = corrmat.abs().unstack() # absolute value of corr coef
    corrmat = corrmat.sort_values(ascending=False)
    corrmat = corrmat[corrmat >= threshold]
    corrmat = corrmat[corrmat < 1] # remove the digonal
    corrmat = pd.DataFrame(corrmat).reset_index()
    corrmat.columns = ['feature1', 'feature2', 'corr']

    grouped_feature_ls = []
    correlated_groups = []

    for feature in corrmat.feature1.unique():
        if feature not in grouped_feature_ls:

            # find all features correlated to a single feature
            correlated_block = corrmat[corrmat.feature1 == feature]
            grouped_feature_ls = grouped_feature_ls + list(
                correlated_block.feature2.unique()) + [feature]

            # append the block of features to the list
            correlated_groups.append(correlated_block)
    return correlated_groups

# Correlation method
# remove features that are highly correlated with each other
corr = corr_feature_detect(data=train_X_std,threshold=0.8)
print(corr)

# No feature reduction can be done using this method as well (check below output)

"""## Reduce number of Features based on Mutual information measure"""

from sklearn.feature_selection import mutual_info_classif,chi2
from sklearn.feature_selection import SelectKBest, SelectPercentile
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.metrics import roc_auc_score, mean_squared_error

def mutual_info(X,y,select_k=10):
    if select_k >= 1:
        sel_ = SelectKBest(mutual_info_classif, k=select_k).fit(X, y)
        selected_indices = sel_.get_support(indices=True)
    elif 0 < select_k < 1:
        sel_ = SelectPercentile(mutual_info_classif, percentile=select_k*100).fit(X, y)
        selected_indices = sel_.get_support(indices=True)
    else:
        raise ValueError("select_k must be a positive number")

    X_selected = X.iloc[:, selected_indices]
    return X_selected, selected_indices

# Mutual Information Filter
# Mutual information measures how much information the presence/absence of a feature contributes to making the
# correct prediction on Y.

mi_top_95_percent_train_for_ids, selected_indices_for_ids = mutual_info(X=train_X_std, y=train_speaker_IDs, select_k=0.95)
mi_top_95_percent_train_for_ages, selected_indices_for_ages = mutual_info(X=train_X_std, y=train_speaker_ages, select_k=0.95)
mi_top_95_percent_train_for_genders, selected_indices_for_genders = mutual_info(X=train_X_std, y=train_speaker_genders, select_k=0.95)
mi_top_95_percent_train_for_accents, selected_indices_for_accents = mutual_info(X=train_X_std, y=train_speaker_accents, select_k=0.95)

# Slice the original Train DataFrame using the selected indices
df_top_95_percent_train_for_ids = train_X_std.iloc[:, selected_indices_for_ids]
df_top_95_percent_train_for_ages = train_X_std.iloc[:, selected_indices_for_ages]
df_top_95_percent_train_for_genders = train_X_std.iloc[:, selected_indices_for_genders]
df_top_95_percent_train_for_accents = train_X_std.iloc[:, selected_indices_for_accents]

# Print the resulting DataFrame
print(df_top_95_percent_train_for_ids.shape)
print(df_top_95_percent_train_for_ages.shape)
print(df_top_95_percent_train_for_genders.shape)
print(df_top_95_percent_train_for_accents.shape)

# This technique has reduced features as per the below output

# Slice the original validation DataFrame using the selected indices
df_top_95_percent_valid_for_ids = valid_X_std.iloc[:, selected_indices_for_ids]
df_top_95_percent_valid_for_ages = valid_X_std.iloc[:, selected_indices_for_ages]
df_top_95_percent_valid_for_genders = valid_X_std.iloc[:, selected_indices_for_genders]
df_top_95_percent_valid_for_accents = valid_X_std.iloc[:, selected_indices_for_accents]

# Print the resulting DataFrame
print(df_top_95_percent_valid_for_ids.shape)
print(df_top_95_percent_valid_for_ages.shape)
print(df_top_95_percent_valid_for_genders.shape)
print(df_top_95_percent_valid_for_accents.shape)

run_models_and_check_with_test_dataset(df_top_95_percent_train_for_ids, train_speaker_IDs, df_top_95_percent_valid_for_ids, valid_speaker_IDs)
run_models_and_check_with_test_dataset(df_top_95_percent_train_for_ages, train_speaker_ages, df_top_95_percent_valid_for_ages, valid_speaker_ages)
run_models_and_check_with_test_dataset(df_top_95_percent_train_for_genders, train_speaker_genders, df_top_95_percent_valid_for_genders, valid_speaker_genders)
run_models_and_check_with_test_dataset(df_top_95_percent_train_for_accents, train_speaker_accents, df_top_95_percent_valid_for_accents, valid_speaker_accents)

run_models_and_check_with_train_test_split_on_train_dataset(df_top_95_percent_train_for_ids, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(df_top_95_percent_train_for_ages, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(df_top_95_percent_train_for_genders, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(df_top_95_percent_train_for_accents, train_speaker_accents)

"""## Univariate MSE
builds one decision tree per feature, to predict the target, then make predictions and ranks the features according to the machine learning metric (mse)
"""

(train_X_std.dtypes == float).count()

def univariate_mse(X_train,y_train,X_test,y_test,threshold):
  """
  First, it builds one decision tree per feature, to predict the target
  Second, it makes predictions using the decision tree and the mentioned feature
  Third, it ranks the features according to the machine learning metric (roc-auc or mse)
  It selects the highest ranked features

  """
  mse_values = []
  for feature in X_train.columns:
      clf = DecisionTreeRegressor()
      clf.fit(X_train[feature].to_frame(), y_train)
      y_scored = clf.predict(X_test[feature].to_frame())
      mse_values.append(mean_squared_error(y_test, y_scored))
  mse_values = pd.Series(mse_values)
  mse_values.index = X_train.columns
  n = len(mse_values)
  if threshold > 1:
    print("The threshold value should be less than 1")
    return
  else:
    n_selected = int(threshold * n)
    print("Number of original features: " + str(n))
    print("Number of selected features: " + str(n_selected) + " (Based on the threshold: " + str(threshold) + ")")
    keep_col = mse_values[: n_selected]
    return keep_col

X_train_temp, X_test_temp, y_train_temp, y_test_temp = train_test_split(train_X_std, train_speaker_IDs, test_size=0.2, random_state=42)

uni_mse = univariate_mse(X_train=X_train_temp, y_train=y_train_temp,
                                 X_test=X_test_temp, y_test=y_test_temp, threshold=0.8)

selected_feature_names = uni_mse.index.tolist()
selected_features_train_X = train_X_std[selected_feature_names]
selected_features_valid_X = valid_X_std[selected_feature_names]

print(selected_features_train_X.shape)
print(selected_features_valid_X.shape)

run_models_and_check_with_test_dataset(selected_features_train_X, train_speaker_IDs, selected_features_valid_X, valid_speaker_IDs)

#Though the features got reduced to 204 (from 256), the accuracy dropped to 0.9906666666666667 from 0.992

run_models_and_check_with_train_test_split_on_train_dataset(selected_features_train_X, train_speaker_IDs)

#Though the features got reduced to 204 (from 256), the accuracy dropped to 0.9919354838709677 from 0.9921107994389902

"""## Model-Based Feature Selection"""

import pandas as pd
import numpy as np
# import seaborn as sns
# import matplotlib.pyplot as plt
import os
from sklearn.model_selection import train_test_split
from mlxtend.feature_selection import SequentialFeatureSelector as SFS
from mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier

from sklearn.linear_model import LogisticRegression
from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import classification_report
from sklearn.svm import LinearSVC

from sklearn.model_selection import train_test_split
from sklearn.linear_model import Lasso, LogisticRegression
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import SelectFromModel

# Create a separate SelectFromModel instance for each target variable
select_for_IDs = SelectFromModel(LogisticRegression(C=0.01, penalty='l1', solver='liblinear', class_weight='balanced'))
select_for_ages = SelectFromModel(LogisticRegression(C=0.01, penalty='l1', solver='liblinear', class_weight='balanced'))
select_for_genders = SelectFromModel(LogisticRegression(C=0.01, penalty='l1', solver='liblinear', class_weight='balanced'))
select_for_accents = SelectFromModel(LogisticRegression(C=0.01, penalty='l1', solver='liblinear', class_weight='balanced'))

# ===========================
select_for_IDs = select_for_IDs.fit(train_X_std, train_speaker_IDs)
select_for_ages = select_for_ages.fit(train_X_std, train_speaker_ages)
select_for_genders = select_for_genders.fit(train_X_std, train_speaker_genders)
select_for_accents = select_for_accents.fit(train_X_std, train_speaker_accents)

selected_X_for_IDs = select_for_IDs.transform(train_X_std)
selected_X_for_ages = select_for_ages.transform(train_X_std)
selected_X_for_genders = select_for_genders.transform(train_X_std)
selected_X_for_accents = select_for_accents.transform(train_X_std)
# ===========================

# Fit each SelectFromModel instance and transform the data
# selected_X_for_IDs = select_for_IDs.fit_transform(train_X_std, train_speaker_IDs)
# selected_X_for_ages = select_for_ages.fit_transform(train_X_std, train_speaker_ages)
# selected_X_for_genders = select_for_genders.fit_transform(train_X_std, train_speaker_genders)
# selected_X_for_accents = select_for_accents.fit_transform(train_X_std, train_speaker_accents)

# Get the indices of selected features for each target variable
# selected_indices_for_IDs = select_for_IDs.get_support(indices=True)
# selected_indices_for_ages = select_for_ages.get_support(indices=True)
# selected_indices_for_genders = select_for_genders.get_support(indices=True)
# selected_indices_for_accents = select_for_accents.get_support(indices=True)

# # Get the names of the selected columns
# selected_column_names_for_IDs = train_X_std.columns[selected_indices_for_IDs]
# selected_column_names_for_ages = train_X_std.columns[selected_indices_for_ages]
# selected_column_names_for_genders = train_X_std.columns[selected_indices_for_genders]
# selected_column_names_for_accents = train_X_std.columns[selected_indices_for_accents]

# # Extract the selected columns from the validation set
# reduced_validation_for_IDs = valid_X_std[selected_column_names_for_IDs]
# reduced_validation_for_ages = valid_X_std[selected_column_names_for_ages]
# reduced_validation_for_genders = valid_X_std[selected_column_names_for_genders]
# reduced_validation_for_accents = valid_X_std[selected_column_names_for_accents]

# ============================
reduced_validation_for_IDs = select_for_IDs.transform(valid_X_std)
reduced_validation_for_ages = select_for_ages.transform(valid_X_std)
reduced_validation_for_genders = select_for_genders.transform(valid_X_std)
reduced_validation_for_accents = select_for_accents.transform(valid_X_std)
# ==============================

# Print the resulting DataFrame (reduced version of training dataFrame)
print("Reduced version of training dataFrame:")
print(selected_X_for_IDs.shape)
print(selected_X_for_ages.shape)
print(selected_X_for_genders.shape)
print(selected_X_for_accents.shape)

# Print the resulting DataFrame (reduced version of validation dataFrame)
print("\nReduced version of validation dataFrame:")
print(reduced_validation_for_IDs.shape)
print(reduced_validation_for_ages.shape)
print(reduced_validation_for_genders.shape)
print(reduced_validation_for_accents.shape)

run_models_and_check_with_test_dataset(selected_X_for_IDs, train_speaker_IDs, reduced_validation_for_IDs, valid_speaker_IDs)
run_models_and_check_with_test_dataset(selected_X_for_ages, train_speaker_ages, reduced_validation_for_ages, valid_speaker_ages)
run_models_and_check_with_test_dataset(selected_X_for_genders, train_speaker_genders, reduced_validation_for_genders, valid_speaker_genders)
run_models_and_check_with_test_dataset(selected_X_for_accents, train_speaker_accents, reduced_validation_for_accents, valid_speaker_accents)

run_models_and_check_with_train_test_split_on_train_dataset(selected_X_for_IDs, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(selected_X_for_ages, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(selected_X_for_genders, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(selected_X_for_accents, train_speaker_accents)

"""## Random Forest Importance"""

from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier #RandomForestRegressor
#from sklearn.feature_selection import SelectFromModel

def rf_importance(X_train,y_train,max_depth=10,class_weight=None,top_n=15,n_estimators=50,random_state=0):

    model = RandomForestClassifier(n_estimators=n_estimators,max_depth=max_depth,
                                    random_state=random_state,class_weight=class_weight,
                                    n_jobs=-1)
    model.fit(X_train, y_train)
    importances = model.feature_importances_
    indices = np.argsort(importances)[::-1]
    feat_labels = X_train.columns
    std = np.std([tree.feature_importances_ for tree in model.estimators_],
                 axis=0) #  inter-trees variability.
    print("Feature ranking:")
    for f in range(X_train.shape[1]):
        print("%d. feature no:%d feature name:%s (%f)" % (f + 1, indices[f], feat_labels[indices[f]], importances[indices[f]]))

    # plotting
    indices = indices[0:top_n]
    plt.figure()
    plt.title("Feature importances top %d" % top_n)
    plt.bar(range(top_n), importances[indices],
           color="r", yerr=std[indices], align="center")
    plt.xticks(range(top_n), indices)
    plt.xlim([-1,top_n])
    plt.show()

    return model

model_for_IDs = rf_importance(X_train=train_X_std, y_train=train_speaker_IDs, max_depth=10,top_n=100)
model_for_ages = rf_importance(X_train=train_X_std, y_train=train_speaker_ages, max_depth=10,top_n=100)
model_for_genders = rf_importance(X_train=train_X_std, y_train=train_speaker_genders, max_depth=10,top_n=100)
model_for_accents = rf_importance(X_train=train_X_std, y_train=train_speaker_accents, max_depth=10,top_n=100)

from sklearn.feature_selection import SelectFromModel

# only 5 features have importance > 0.05
feature_selection_for_IDs = SelectFromModel(model_for_IDs, threshold=0.0013,prefit=True)  #0.0015 => 244
#0.0013 => 250 Accuracy INCREASED: 0.99228611500701

feature_selection_for_ages = SelectFromModel(model_for_ages, threshold=0.0013,prefit=True)
# 0.0013 => 0.9737026647966339 | 255 | dec

feature_selection_for_genders = SelectFromModel(model_for_genders, threshold=0.0013,prefit=True)
feature_selection_for_accents = SelectFromModel(model_for_accents, threshold=0.0013,prefit=True)

selected_train_feat_for_IDs = train_X_std[train_X_std.columns[(feature_selection_for_IDs.get_support())]]
selected_train_feat_for_ages = train_X_std[train_X_std.columns[(feature_selection_for_ages.get_support())]]
selected_train_feat_for_genders = train_X_std[train_X_std.columns[(feature_selection_for_genders.get_support())]]
selected_train_feat_for_accents = train_X_std[train_X_std.columns[(feature_selection_for_accents.get_support())]]

# Print the resulting DataFrame (reduced version of training dataFrame)
print("Reduced version of training dataFrame:")
print(selected_train_feat_for_IDs.shape)
print(selected_train_feat_for_ages.shape)
print(selected_train_feat_for_genders.shape)
print(selected_train_feat_for_accents.shape)

selected_valid_feat_for_IDs = valid_X_std[valid_X_std.columns[(feature_selection_for_IDs.get_support())]]
selected_valid_feat_for_ages = valid_X_std[valid_X_std.columns[(feature_selection_for_ages.get_support())]]
selected_valid_feat_for_genders = valid_X_std[valid_X_std.columns[(feature_selection_for_genders.get_support())]]
selected_valid_feat_for_accents = valid_X_std[valid_X_std.columns[(feature_selection_for_accents.get_support())]]

# Print the resulting DataFrame (reduced version of validation dataFrame)
print("Reduced version of validation dataFrame:")
print(selected_valid_feat_for_IDs.shape)
print(selected_valid_feat_for_ages.shape)
print(selected_valid_feat_for_genders.shape)
print(selected_valid_feat_for_accents.shape)

run_models_and_check_with_test_dataset(selected_train_feat_for_IDs, train_speaker_IDs, selected_valid_feat_for_IDs, valid_speaker_IDs)
run_models_and_check_with_test_dataset(selected_train_feat_for_ages, train_speaker_ages, selected_valid_feat_for_ages, valid_speaker_ages)
run_models_and_check_with_test_dataset(selected_train_feat_for_genders, train_speaker_genders, selected_valid_feat_for_genders, valid_speaker_genders)
run_models_and_check_with_test_dataset(selected_train_feat_for_accents, train_speaker_accents, selected_valid_feat_for_accents, valid_speaker_accents)

run_models_and_check_with_train_test_split_on_train_dataset(selected_train_feat_for_IDs, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(selected_train_feat_for_ages, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(selected_train_feat_for_genders, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(selected_train_feat_for_accents, train_speaker_accents)

"""## PCA"""

from sklearn.decomposition import PCA
import numpy as np

# Create a PCA model with the desired explained variance threshold
pca = PCA(n_components=0.96)

# Fit the PCA model on the training data
pca.fit(train_X_std)

# Transform the training and validation data using the PCA model
reduced_train_X_pca = pca.transform(train_X_std)
reduced_validation_X_pca = pca.transform(valid_X_std)

# Print the shapes of the reduced datasets
print("Reduced Training Data Shape:", reduced_train_X_pca.shape)
print("Reduced Validation Data Shape:", reduced_validation_X_pca.shape)

run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_IDs, reduced_validation_X_pca, valid_speaker_IDs)
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_ages, reduced_validation_X_pca, valid_speaker_ages)
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_genders, reduced_validation_X_pca, valid_speaker_genders)
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_accents, reduced_validation_X_pca, valid_speaker_accents)

run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_accents)



"""# Conclusion

Based on above results of all the techniques, these are the optimal ways to reduce the features based on each class label.

![image.png](data:image/png;base64,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)
"""

print("CONCLUSION")
print("Features reduced (to 73) based on 'PCA' will be used for : SPEAKER_ID class labels")
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_IDs, reduced_validation_X_pca, valid_speaker_IDs)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_IDs)
print()

print("Features reduced (to 73) based on 'PCA' will be used for : SPEAKER_AGE class labels ")
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_ages, reduced_validation_X_pca, valid_speaker_ages)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_ages)
print()

print('Features reduced (to 40) based on "Model-based feature selection" will be used for : SPEAKER_GENDER class labels')
run_models_and_check_with_test_dataset(selected_X_for_genders, train_speaker_genders, reduced_validation_for_genders, valid_speaker_genders)
run_models_and_check_with_train_test_split_on_train_dataset(selected_X_for_genders, train_speaker_genders)
print()

print('Features reduced (to 73) based on "PCA" will be used for : SPEAKER_ACCENT class labels ')
run_models_and_check_with_test_dataset(reduced_train_X_pca, train_speaker_accents, reduced_validation_X_pca, valid_speaker_accents)
run_models_and_check_with_train_test_split_on_train_dataset(reduced_train_X_pca, train_speaker_accents)
print()

"""# Predicting for Test data

## Importing
"""

test_data_file_path = "/content/drive/MyDrive/SEM 7 - ML/Lab 1 - Feature Engineering/test.csv"
# importing test  dataset

test_df = pd.read_csv(test_data_file_path)
print(test_df.shape)
test_df.head()

test_df = test_df.drop(columns=['label_1','label_2','label_3','label_4'])
test_df.head()

"""## Check for null values"""

# Check for null/NaN values in all columns
print(test_df.isna().any())
print(test_df.isna().any().sum().sum())
# No null values  based on the below output

test_df.describe()

"""## Standardizing features"""

from sklearn.preprocessing import StandardScaler

test_X_std = pd.DataFrame()
new_columns = []

test_X_std = ss.transform(test_df)
test_X_std = pd.DataFrame(test_X_std)

test_X_std.describe()

test_X_std.shape

"""## Model-based feature selection (for SPEAKER_GENDER class label)"""

train_select_for_genders = SelectFromModel(LogisticRegression(C=0.01, penalty='l1', solver='liblinear', class_weight='balanced'))
train_fitted_for_genders = train_select_for_genders.fit(train_X_std, train_speaker_genders)


reduced_test_data_for_genders = train_fitted_for_genders.transform(test_X_std)
reduced_test_data_for_genders = pd.DataFrame(reduced_test_data_for_genders)

print(reduced_test_data_for_genders.shape)

reduced_test_data_for_genders.head()

"""### The Prediction

For all the previous model results, SVM gave the best accuracies. Therefore for the prediction of test data also the SVM is used. Also I used: "class_weight='balanced" to tackle the class imbalance issues
"""

import warnings

# For all the previous model results SVM
def predict_using_svm(train_features, train_class_labels, test_features):

  warnings.filterwarnings("ignore")

  svm_model = SVC(class_weight='balanced')
  svm_model.fit(train_features, train_class_labels)

  # Predict on the test set
  svm_predictions = svm_model.predict(test_features)
  return svm_predictions

# NOTE: from the "Model-based feature selection" section in this notebook, the reduced feature set for speaker_gender class labels
# were saved under the variable name: "selected_X_for_genders"
print(selected_X_for_genders.shape)
predicted_speaker_gender_labels_after_feature_eng = predict_using_svm(selected_X_for_genders, train_speaker_genders, reduced_test_data_for_genders)

len(predicted_speaker_gender_labels_after_feature_eng)

reduced_test_X_model_based_df = pd.DataFrame(reduced_test_data_for_genders)
reduced_test_X_model_based_df.shape

if "Predicted labels after feature engineering" not in reduced_test_X_model_based_df.columns:
    lab_1_label_1_df = reduced_test_X_model_based_df.insert(0, "Predicted labels after feature engineering", predicted_speaker_gender_labels_after_feature_eng)
else:
    print(f"Column : Predicted labels after feature engineering already exists.")

print(reduced_test_X_model_based_df.shape)
reduced_test_X_model_based_df.head()

print(train_X_std.shape)
print(test_df.shape)

predicted_speaker_gender_labels_before_feature_engineering = predict_using_svm(train_X, train_speaker_genders, test_df)

len(predicted_speaker_gender_labels_before_feature_engineering)

if "Predicted labels before feature engineering" not in reduced_test_X_model_based_df.columns:
    lab_1_label_1_df = reduced_test_X_model_based_df.insert(0, "Predicted labels before feature engineering", predicted_speaker_gender_labels_before_feature_engineering)
else:
    print(f"Column : Predicted labels before feature engineering already exists.")

print(reduced_test_X_model_based_df.shape)
reduced_test_X_model_based_df.head()

reduced_test_X_model_based_df.shape

no_of_new_features = reduced_test_X_model_based_df.shape[1] - 2
no_of_new_features

if "No of new features" not in reduced_test_X_model_based_df.columns:
    lab_1_label_1_df = reduced_test_X_model_based_df.insert(2, "No of new features", no_of_new_features)
else:
    print(f"Column : No of new features already exists.")

print(reduced_test_X_model_based_df.shape)
reduced_test_X_model_based_df.head()

temp_df = reduced_test_X_model_based_df.copy(deep=True)

temp_df.head()

no_of_new_features

# Define the new column names
new_column_names = ['Predicted labels before feature engineering',
                    'Predicted labels after feature engineering',
                    'No of new features'] + [f'new_feature_{i+1}' for i in range(no_of_new_features)]

# Rename the columns
temp_df.columns = new_column_names

temp_df.head()

temp_df.to_csv('190290U_label_3.csv', index=False)

"""## PCA (for other 3 class labels)"""

reduced_test_X_pca = pca.transform(test_X_std)

print("Reduced Test Data Shape:", reduced_test_X_pca.shape)

"""### The Prediction

For all the previous model results, SVM gave the best accuracies. Therefore for the prediction of test data also the SVM is used

#### speaker IDs
"""

predicted_speaker_ID_labels_after_feature_eng = predict_using_svm(reduced_train_X_pca, train_speaker_IDs, reduced_test_X_pca)

len(predicted_speaker_ID_labels_after_feature_eng)

reduced_test_X_pca_df = pd.DataFrame(reduced_test_X_pca)
reduced_test_X_pca_df.shape

if "Predicted labels after feature engineering" not in reduced_test_X_pca_df.columns:
    lab_1_label_1_df = reduced_test_X_pca_df.insert(0, "Predicted labels after feature engineering", predicted_speaker_ID_labels_after_feature_eng)
else:
    print(f"Column : Predicted labels after feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

predicted_speaker_ID_labels_before_feature_engineering = predict_using_svm(train_X, train_speaker_IDs, test_df)

len(predicted_speaker_ID_labels_before_feature_engineering)

if "Predicted labels before feature engineering" not in reduced_test_X_pca_df.columns:
    reduced_test_X_pca_df.insert(0, "Predicted labels before feature engineering", predicted_speaker_ID_labels_before_feature_engineering)
else:
    print(f"Column : Predicted labels before feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

no_of_new_features = reduced_test_X_pca_df.shape[1] - 2
no_of_new_features

if "No of new features" not in reduced_test_X_pca_df.columns:
    lab_1_label_1_df = reduced_test_X_pca_df.insert(2, "No of new features", no_of_new_features)
else:
    print(f"Column : No of new features already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

temp_df = reduced_test_X_pca_df.copy(deep=True)

temp_df.head()

no_of_new_features

# Define the new column names
new_column_names = ['Predicted labels before feature engineering',
                    'Predicted labels after feature engineering',
                    'No of new features'] + [f'new_feature_{i+1}' for i in range(no_of_new_features)]

# Rename the columns
temp_df.columns = new_column_names

temp_df.head()

temp_df.to_csv('190290U_label_1.csv', index=False)

"""#### speaker ages"""

predicted_speaker_age_labels_after_feature_eng = predict_using_svm(reduced_train_X_pca, train_speaker_ages, reduced_test_X_pca)

len(predicted_speaker_age_labels_after_feature_eng)

reduced_test_X_pca_df = pd.DataFrame(reduced_test_X_pca)
reduced_test_X_pca_df.shape

if "Predicted labels after feature engineering" not in reduced_test_X_pca_df.columns:
    reduced_test_X_pca_df.insert(0, "Predicted labels after feature engineering", predicted_speaker_age_labels_after_feature_eng)
else:
    print(f"Column : Predicted labels after feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

predicted_speaker_age_labels_before_feature_engineering = predict_using_svm(train_X, train_speaker_ages, test_df)

len(predicted_speaker_age_labels_before_feature_engineering)

if "Predicted labels before feature engineering" not in reduced_test_X_pca_df.columns:
    reduced_test_X_pca_df.insert(0, "Predicted labels before feature engineering", predicted_speaker_age_labels_before_feature_engineering)
else:
    print(f"Column : Predicted labels before feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

no_of_new_features = reduced_test_X_pca_df.shape[1] - 2
no_of_new_features

if "No of new features" not in reduced_test_X_pca_df.columns:
    lab_1_label_1_df = reduced_test_X_pca_df.insert(2, "No of new features", no_of_new_features)
else:
    print(f"Column : No of new features already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

temp_df = reduced_test_X_pca_df.copy(deep=True)

temp_df.head()

no_of_new_features

# Define the new column names
new_column_names = ['Predicted labels before feature engineering',
                    'Predicted labels after feature engineering',
                    'No of new features'] + [f'new_feature_{i+1}' for i in range(no_of_new_features)]

# Rename the columns
temp_df.columns = new_column_names

temp_df.head()

temp_df.to_csv('190290U_label_2.csv', index=False)

"""#### speaker accents"""

predicted_speaker_accent_labels_after_feature_eng = predict_using_svm(reduced_train_X_pca, train_speaker_accents, reduced_test_X_pca)

len(predicted_speaker_accent_labels_after_feature_eng)

reduced_test_X_pca_df = pd.DataFrame(reduced_test_X_pca)
reduced_test_X_pca_df.shape

if "Predicted labels after feature engineering" not in reduced_test_X_pca_df.columns:
    reduced_test_X_pca_df.insert(0, "Predicted labels after feature engineering", predicted_speaker_accent_labels_after_feature_eng)
else:
    print(f"Column : Predicted labels after feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

predicted_speaker_accent_labels_before_feature_engineering = predict_using_svm(train_X, train_speaker_accents, test_df)

len(predicted_speaker_accent_labels_before_feature_engineering)

if "Predicted labels before feature engineering" not in reduced_test_X_pca_df.columns:
    reduced_test_X_pca_df.insert(0, "Predicted labels before feature engineering", predicted_speaker_accent_labels_before_feature_engineering)
else:
    print(f"Column : Predicted labels before feature engineering already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

no_of_new_features = reduced_test_X_pca_df.shape[1] - 2
no_of_new_features

if "No of new features" not in reduced_test_X_pca_df.columns:
    lab_1_label_1_df = reduced_test_X_pca_df.insert(2, "No of new features", no_of_new_features)
else:
    print(f"Column : No of new features already exists.")

print(reduced_test_X_pca_df.shape)
reduced_test_X_pca_df.head()

temp_df = reduced_test_X_pca_df.copy(deep=True)

temp_df.head()

no_of_new_features

# Define the new column names
new_column_names = ['Predicted labels before feature engineering',
                    'Predicted labels after feature engineering',
                    'No of new features'] + [f'new_feature_{i+1}' for i in range(no_of_new_features)]

# Rename the columns
temp_df.columns = new_column_names

temp_df.head()

temp_df.to_csv('190290U_label_4.csv', index=False)

